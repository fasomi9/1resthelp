# Name:helpcat
# Description: —Å–ª–µ–≥–∫–∞ —É–ª—É—á—à–µ–Ω—ã–π Help 
# Author:@shyatzd 
# scope:hikka_only
# scope:hikka_min 1.6.0
# meta developer:@shyatzd
# Commands:
# .kh | .khc | 
import inspect
from .. import loader, utils, main, security


@loader.tds
class HelpcatMod(loader.Module):
    """–ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —ç—Ç–æ —Å–ø—Ä–∞–≤–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ""" 
    strings = {"name": "helpcat",
               "bad_module": '<b>üåò I don\'t know what</b> "<code>{}</code>" <b>is!</b>',
               "single_mod_header": "<b>üåò Info about</b> <u>{}</u>:\n",
               "undoc_cmd": "üåò No docs",
              "all_header": 'üåò <b>{} mods available:</b>',
              "mod_tmpl": '\nüá¨üáß <code>{}</code>',
              "first_cmd_tmpl": ": ( {}",
               "cmd_tmpl": " | {}",
              "args": "üåò <b>Args are incorrect</b>",
               "set_cat": "üåò <b>{} -> {}</b>"}

    strings_ru = {"bad_module": '<b>üåò –Ø –Ω–µ –∑–Ω–∞—é, —á—Ç–æ</b> "<code>{}</code>" <b>—ç—Ç–æ!</b>',
               "single_mod_header": "<b>üåò –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ</b> <u>{}</u>:\n",
               "undoc_cmd": "üåò –ù–∏–∫–∞–∫–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –Ω–µ—Ç",
              "all_header": 'üåò <b>{} –¥–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥—ã:</b>',
              "mod_tmpl": '\nüá∑üá∫ <code>{}</code>',
              "first_cmd_tmpl": ": ( {}",
               "cmd_tmpl": " | {}",
              "args": "üåò <b>–ê—Ä–≥—É–º–µ–Ω—Ç—ã –Ω–µ–≤–µ—Ä–Ω—ã</b>",
               "set_cat": "üåò <b>{} -> {}</b>"}
    
    async def khccmd(self, message):
        """.khc <module>: <category> - –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è –º–æ–¥—É–ª—è 
        –ø—Ä–∏–º–µ—Ä .khc HikariChat: admintool"""
        args = utils.get_args_raw(message).split(':')
        if len(args) != 2:
            await utils.answer(message, self.strings('args', message))
            return

        module_args, cat = args[0].strip(), args[1].strip()
        module = None
        for mod in self.allmodules.modules:
            if mod.strings("name", message).lower() == module_args.lower():
                module = mod

        if module is None:
            await utils.answer(message, self.strings('bad_module', message).format(module_args))
            return

        cats = self.db.get('Help', 'cats', {})
        if cat == "":
            del cats[module_args]
        else:
            cats[module_args] = cat
        self.db.set('Help', 'cats', cats)
        await utils.answer(message, self.strings('set_cat', message).format(*args))

    @loader.unrestricted
    async def khcmd(self, message):
        """.kh [module] –ø–æ–º–æ—â—å –ø–æ –º–æ–¥—É–ª—é [-c <category>] –ø–æ–º–æ—â—å –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º - –ø–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–æ—á–Ω—ã–π –ª–∏—Å—Ç""" 
        args = utils.get_args_raw(message)
        force = False
        print(args)
        if '-f' in args:
            args = args.replace(' -f', '').replace('-f', '')
            force = True
        
        category = None
        if "-c" in args:
            category = args[args.find('-c ') + 3:]
            args = args[:args.find('-c ')]

        id = message.sender_id
        if args:
            module = None
            for mod in self.allmodules.modules:
                if mod.strings("name", message).lower() == args.lower():
                    module = mod
            if module is None:
                await utils.answer(message, self.strings("bad_module", message).format(args))
                return
            # Translate the format specification and the module separately
            try:
                name = module.strings("name", message)
            except KeyError:
                name = getattr(module, "name", "ERROR")
            reply = self.strings("single_mod_header", message).format(utils.escape_html(name), utils.escape_html((self.db.get(main.__name__, "command_prefix", False) or ".")[0]))
            if module.__doc__:
                reply += "\n" +  "\n".join("  " + t for t in utils.escape_html(inspect.getdoc(module)).split("\n"))
            commands = {name: func for name, func in module.commands.items() if await self.allmodules.check_security(message, func)}
            for name, fun in commands.items():
                reply += self.strings("single_cmd", message).format(name)
                if fun.__doc__:
                    reply += utils.escape_html("\n".join("    " + t for t in inspect.getdoc(fun).split("\n")))
                else:
                    reply += self.strings("undoc_cmd", message)
        else:
            count = 0
            for i in self.allmodules.modules:
                try:
                    if len(i.commands) != 0:
                        count += 1
                except:
                    pass
            reply = self.strings("all_header", message).format(count)
            shown_warn = False
            mods_formatted = {}
            for mod in self.allmodules.modules:
                if len(mod.commands) != 0:
                    tmp = ""
                    try:
                        name = mod.strings("name", message)
                    except KeyError:
                        name = getattr(mod, "name", "ERROR")
                    tmp += self.strings("mod_tmpl", message).format(name)
                    first = True
                    commands = [name for name, func in mod.commands.items() if await self.allmodules.check_security(message, func) or force]
                    for cmd in commands:
                        if first:
                            tmp += self.strings("first_cmd_tmpl", message).format(cmd)
                            first = False
                        else:
                            tmp += self.strings("cmd_tmpl", message).format(cmd)
                    if len(commands) == 0:
                        if not shown_warn:
                            reply = '<i>–ü–æ–∫–∞–∑–∞–Ω—ã —Ç–æ–ª—å–∫–æ —Ç–µ –º–æ–¥—É–ª–∏, –¥–ª—è –∫–æ—Ç–æ—Ä—ã—Ö –≤–∞–º —Ö–≤–∞—Ç–∞–µ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è</i>\n' + reply
                            shown_warn = True
                    else:
                        tmp += " )"
                        mods_formatted[name] = tmp

            cats = {}

            for mod_name, cat in self.db.get('Help', 'cats', {}).items():
                if cat not in cats:
                    cats[cat] = []

                cats[cat].append(mod_name)

            if category is None:
                mods_remaining = mods_formatted.copy()
                for cat, mods in cats.items():
                    tmp = ""
                    for mod in mods:
                        if mod in mods_formatted:
                            tmp += mods_formatted[mod]
                            del mods_formatted[mod]
                    if tmp != "":
                        reply += "\n\n<b>‚ú® " + cat + "</b>" + tmp

                if len(mods_formatted) > 0:
                    reply += "\nüîª‚ûñ‚ûñ‚ûñ‚ûñ‚ûñüîª"

                for _, mod_formatted in mods_formatted.items():
                    reply += mod_formatted
            else:
                tmp = ""
                for mod in cats[category]:
                    if mod in mods_formatted:
                        tmp += mods_formatted[mod]
                        del mods_formatted[mod]
                if tmp != "":
                    reply += "\n<b>‚ú® " + category + "</b>" + tmp


        await utils.answer(message, reply)

    async def client_ready(self, client, db):
        self.client = client
        self.is_bot = await client.is_bot()
        self.db = db
